<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <link rel="stylesheet" type="text/css" href="../../stylesheets/bootstrap.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../../stylesheets/style.css" media="screen" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script type="text/javascript" src="../../javascripts/bootstrap.js"></script>
    <script type="text/javascript" src="../../javascripts/bootstrap.bundle.js"></script>
    <title>Сайт о Go: Глава 1</title>
</head>
<body>
<div id="navbar-center">
<nav class="navbar navbar-expand-lg navbar-light bg-light">

    <a class="navbar-brand" href="/"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/Go_Logo_Blue.svg/215px-Go_Logo_Blue.svg.png" style="width: 80px; margin-left: 10px;"></a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    Главы
                </a>
                <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                    <a class="dropdown-item active" href="/article/1">Глава 1: Основы</a>
                    <a class="dropdown-item" href="/article/2">Глава 2: Структуры</a>
                    <a class="dropdown-item" href="/article/3">Глава 3: Массивы, карты и срезы</a>
                    <a class="dropdown-item" href="/article/4">Глава 4: Организация кода и интерфейсы</a>
                    <a class="dropdown-item" href="/article/5">Глава 5: Лакомые кусочки</a>
                    <a class="dropdown-item" href="/article/6">Глава 6: Конкурентность</a>
                </div>
            </li>

            <li class="nav-item">
                <a class="nav-link" href="/about">О сайте</a>
            </li>
        </ul>
    </div>

</nav>
</div>
<div class="content">
    <h1 class="post-title">Глава 1: Основы</h1>

    <p>Go компилируемый язык со статической типизацией. Он имеет C-подобный синтаксис и сборку мусора. Что это означает?</p>

    <h2 id="">Компиляция</h2>

    <p>Компиляция это процесс перевода исходного кода, который написали вы, в язык более низкого уровня – либо ассемблер (как в случае с Go), либо в какой-то другой промежуточный язык (как в случае с Java или C#).</p>

    <p>С компилируемыми языками бывает неприятно работать потому, что компиляция может быть медленной. Сложно совершать быстрые итерации, если вы тратите минуты или часы в ожидании компиляции вашего кода. Скорость компиляции является одной из основных целей Go. Это хорошие новости для людей, которые работают над большими проектами, а так же для тех, кто привык быстро получать обратную связь при работе с интерпретируемыми языками.</p>

    <p>Компилируемые языки, как правило, работают быстрее, и их исполняемые файлы могут быть выполнены без установки дополнительных зависимостей (по крайней мере это верно для таких языков, как C, C++ и Go, которые компилируются непосредственно в ассемблер).</p>

    <h2 id="">Статическая типизация</h2>

    <p>Статическая типизация означает, что все переменные должны быть определенного типа (int, string, bool, []byte, и т. д.). Это достигается либо путем указания типа при объявлении переменной, либо, во многих случаях, тип определяет компилятор (мы скоро увидим примеры).</p>

    <p>Можно много говорить о статической типизации, но я считаю, что её лучше понять глядя на код. Если вы использовали языки с динамической типизацией, вам она может показаться громоздкой. Вы не ошибаетесь, но есть и преимущества, особенно когда она используется в сочетании с компиляцией. Эти две особенности нередко объединяются. Когда есть одна, обычно присутствует и другая, но это не строгое правило. Со строгой системой типов, компилятор может обнаруживать проблемы, которые выходят за рамки синтаксических ошибок, а также проводить дополнительную оптимизацию.</p>

    <h2 id="c">C-подобный синтаксис</h2>

    <p>Говоря о том, что язык имеет C-подобный синтаксис, имеется ввиду то, что если вы уже использовали любой другой C-подобный язык как C, C++, Java, JavaScript и C#, то Go вам покажется похожим – по крайней мере на первый взгляд. Например, это значит, что <code>&amp;&amp;</code> используется как логическое И, <code>==</code> применяется для сравнения, <code>{</code> и <code>}</code> обозначает начало и конец области видимости, а индексы массивов начинаются с 0.</p>

    <p>C-подобный синтаксис также имеет тенденцию к постановке точки с запятой в окончании строк и использовании скобок вокруг условий. В Go нет ни того, ни другого, хотя скобки все еще используются для разделения приоритета. Например, оператор <code>if</code> выглядит так:</p>

    <pre><code class="language-go">if name == "Leto" {
  print("the spice must flow")
}
</code></pre>

    <p>Но в более сложных случаях скобки все еще полезны:</p>

    <pre><code class="language-go">if (name == "Goku" &amp;&amp; power &gt; 9000) || (name == "gohan" &amp;&amp; power &lt; 4000)  {
  print("super Saiyan")
}
</code></pre>

    <p>Помимо этого, Go гораздо ближе к C, чем к C# или Java - не только с точки зрения синтаксиса, но и с точки зрения назначения. Это отражается в лаконичности и простоте языка, которая, надеюсь, будет очевидной, как только вы начнете изучать его.</p>

    <h2 id="">Сборка мусора</h2>

    <p>Некоторые переменные при создании имеют легко определяемую жизнь. Локальная переменная функции, например, исчезает при выходе из функции. В других случаях это не так очевидно, по крайней мере для компилятора. Например, жизнь переменной, которая была возвращена функцией или на которую ссылаются другие переменные и объекты, бывает сложно определить. Без сборки мусора задачей разработчика являлась очистка памяти от переменных там, где по их мнению они не нужны. Как? В C, вы выполняли <code>free(str);</code> для переменной.</p>

    <p>Языки со сборщиками мусора (такие, как Ruby, Python, Java, JavaScript, C#, Go) способны отслеживать и освобождать переменные. которые больше не используются. Сборка мусора добавляет свои накладные расходы, но также устраняет ряд разрушительных ошибок.</p>

    <h2 id="go">Запуск Go кода</h2>

    <p>Давайте начнем наше путешествие созданием простой программы и научимся её компилировать и выполнять. Откройте ваш любимый текстовый редактор и наберите следующий код:</p>

    <pre><code class="language-go">package main

func main() {
  println("it's over 9000!")
}
</code></pre>

    <p>Сохраните файл с именем <code>main.go</code>. Сейчас, вы можете сохранить его где угодно; не обязательно использовать рабочее пространство Go для тривиальных примеров.</p>

    <p>Затем откройте оболочку/командную строку и перейдите в папку, в которую вы сохранили файл. Мне для этого нужно было набрать <code>cd ~/code</code>.</p>

    <p>Наконец, запустите программу, введя:</p>

    <pre><code>go run main.go
</code></pre>

    <p>Если все работает, вы должны увидеть <em>it's over 9000!</em>.</p>

    <p>Но подождите, что насчет этапа с компиляцией? <code>go run</code> это удобная команда, которая компилирует <em>и</em> запускает ваш код. Она использует временную директорию для сборки программы, выполняет её и затем очищает. Вы можете увидеть расположение временной папки выполнив:</p>

    <pre><code>go run --work main.go
</code></pre>

    <p>Чтобы явно скомпилировать код, используйте <code>go build</code>:</p>

    <pre><code>go build main.go
</code></pre>

    <p>Эта команда создаст исполняемый файл <code>main</code> который вы сможете запустить. В Linux / OSX не забудьте, что перед именем выполняемого файла нужно набрать точку и слэш: <code>./main</code>.</p>

    <p>Во время разработки, вы можете использовать <code>go run</code> или <code>go build</code>. Однако в случае развертывания кода, вам нужно переносить бинарный файл, полученный с помощью <code>go build</code> и выполнять его.</p>

    <h3 id="main">Main</h3>

    <p>Надеюсь код, который мы только что выполнили, был понятен. Мы создали функцию и напечатали строку с помощью встроенной функции <code>Println</code>. Команда <code>go run</code> знала что выполнять потому, что у нее не было выбора? Нет, в Go точкой входа в программу является функция с именем <code>main</code> в пакете <code>main</code>.</p>

    <p>Мы поговорим о пакетах в позже. Сейчас, когда вы сфокусированы на понимании основ Go, мы всегда будем писать наш код в пакете <code>main</code>.</p>

    <p>Если хотите, вы можете отредактировать код и изменить имя пакета. Запустите код с помощью команды <code>go run</code> и вы получите ошибку. Затем измените имя обратно на <code>main</code>, но используйте другое имя функции. Вы должны увидеть другое сообщение об ошибке. Попробуйте сделать тоже самое используя команду <code>go build</code>. Обратите внимание на то, что код компилируется, но в нем нет точки входа чтобы запустить его. Это совершенно нормально когда вы, к примеру, создаете библиотеку.</p>

    <h2 id="">Импорты</h2>

    <p>Go имеет ряд встроенных функций, таких как <code>Println</code>, которые могут быть использованы без упоминания. Вы не сможете зайти далеко без использования стандартной библиотеки Go и библиотек других разработчиков. В Go ключевое слово <code>import</code> используется для объявления пакета, который будет использован кодом в файле.</p>

    <p>Давайте изменим нашу программу:</p>

    <pre><code class="language-go">package main

import (
  "fmt"
  "os"
)

func main() {
  if len(os.Args) != 2 {
    os.Exit(1)
  }
  fmt.Println("It's over ", os.Args[1])
}
</code></pre>

    <p>И запустим её с помощью команды:</p>

    <pre><code>go run main.go 9000
</code></pre>

    <p>Здесь мы используем два стандартных пакета Go: <code>fmt</code> и <code>os</code>. Мы также можем увидеть другую встроенную функцию <code>len</code>. <code>len</code> возвращает длину строки, или число значений в словаре, или, как мы видим здесь, число элементов в массиве. Если вам интересно, почему мы ожидаем два аргумента, это потому, что первый аргумент имеет индекс 0 – это всегда путь к текущему исполняемому файлу. (Изменить программу чтобы вывести его и убедитесь сами.)</p>

    <p>Вы наверное заметили префикс перед именем функции, совпадающий с именем пакета, например <code>fmt.Println</code>. Это отличается от многих других языков. Мы узнаем больше о пакетах в следующих главах. Сейчас, знание того, как импортировать и использовать пакеты, уже хороший старт.</p>

    <p>Go строго относится к импорту пакетов. Программа не будет скомпилирована, если вы импортируете пакет и не используете его. Попробуйте выполнить:</p>

    <pre><code class="language-go">package main

import (
  "fmt"
  "os"
)

func main() {
}
</code></pre>

    <p>Вы должны получить две ошибки о том, что <code>fmt</code> и <code>os</code> были импортированы и не использованы. Раздражает ли это? Безусловно. Со временем вы привыкните к этому (хотя это всё равно будет раздражать). Go строг в этом плане потому, что неиспользуемые пакеты замедляют компиляцию; правда у большинства из нас не возникает проблем с этим.</p>

    <p>Еще одна вещь, которую хотелось бы отметить, это то, что стандартная библиотека Go хорошо документирована. Вы можете взглянуть на <a href="http://golang.org/pkg/fmt/#Println">http://golang.org/pkg/fmt/#Println</a> чтобы узнать больше о функции <code>Println</code>, которую мы использовали. Можно кликнуть на заголовок и увидеть её исходный код. Также, промотайте вверх страницы, чтобы узнать больше о возможностях форматирования Go.</p>

    <p>Если у вас нет доступа к Интернету, можно посмотреть документацию локально, выполнив команду:</p>

    <pre><code>godoc -http=:6060
</code></pre>

    <p>И ввести в браузере адрес <code>http://localhost:6060</code></p>

    <h2 id="">Переменные и определения</h2>

    <p>Было бы неплохо начать и закончить обзор переменных просто сказав: <em>вы можете объявить переменную и задать её значение с помощью x = 4.</em> К сожалению в Go все сложнее. Начнем наш разговор глядя на простые примеры. Затем, в следующей главе, познакомимся с ними более подробно рассматривая создание и использование структур. Тем не менее, полное понимание, возможно, займет некоторое время.</p>

    <p>Вы можете подумать <em>Ого! Что тут может быть сложного?</em> Давайте посмотрим на несколько примеров.</p>

    <p>Наиболее явный способ использования переменных в Go также наиболее подробный:</p>

    <pre><code class="language-go">package main

import (
  "fmt"
)

func main() {
  var power int
  power = 9000
  fmt.Printf("It's over %d\n", power)
}
</code></pre>

    <p>Здесь мы определяем переменную <code>power</code> типа <code>int</code>. По умолчанию, Go присваивает переменным нулевые значения. Для целых чисел это <code>0</code>, для булевых <code>false</code>, для строк <code>""</code> и так далее. Затем, мы задаем значение <code>9000</code> для переменной <code>power</code>. Две строки кода можно объединить в одну:</p>

    <pre><code class="language-go">var power int = 9000
</code></pre>

    <p>Все еще много печатать. В Go есть короткий оператор объявления переменных <code>:=</code>, с которым можно объявить тип так:</p>

    <pre><code class="language-go">power := 9000
</code></pre>

    <p>Это удобно и работает и точно также с функциями:</p>

    <pre><code class="language-go">func main() {
  power := getPower()
}

func getPower() int {
  return 9001
}
</code></pre>

    <p>Важно помнить, что <code>:=</code> используется для объявления переменной, а так же задания ей значения. Почему? Потому, что переменную нельзя объявить дважды (по крайней мере в той же области видимости). Если вы попытаетесь выполнить следующее, вы получите ошибку.</p>

    <pre><code class="language-go">func main() {
  power := 9000
  fmt.Printf("It's over %d\n", power)

  // COMPILER ERROR:
  // no new variables on left side of :=
  power := 9001
  fmt.Printf("It's also over %d\n", power)
}
</code></pre>

    <p>Компиляция завершится с сообщением <em>нет новых переменных слева от :=</em>. Это значит, что когда переменная объявляется в первый раз, используется <code>:=</code>, но при последующих присваиваниях используется оператор <code>=</code>. В этом есть большой смысл, но может быть трудным для запоминания когда переключаться между этими операторами.</p>

    <p>Если вы читали сообщение об ошибке внимательно, вы могли заметить, что слово <em>переменные</em> во множественном числе. Это потому, что Go позволяет присваивать несколько значений переменным (использванием <code>=</code> или <code>:=</code>):</p>

    <pre><code class="language-go">func main() {
  name, power := "Goku", 9000
  fmt.Printf("%s's power is over %d\n", name, power)
}
</code></pre>

    <p>До тех пор пока переменная является новой, можно использовать <code>:=</code>. Рассмотрим пример:</p>

    <pre><code class="language-go">func main() {
  power := 1000
  fmt.Printf("default power is %d\n", power)

  name, power := "Goku", 9000
  fmt.Printf("%s's power is over %d\n", name, power)
}
</code></pre>

    <p>Хотя <code>power</code> используется дважды с помощью <code>:=</code>, компилятор не будет жаловаться когда мы будем использовать эту переменную второй раз, он видит что другая переменная <code>name</code> новая и разрешает использовать <code>:=</code>. Однако, вы не можете изменить тип переменой <code>power</code>. Она была объявлена (косвенным образом) как целое число и может принимать только целочисленные значения.</p>

    <p>Теперь, последнее что нужно знать, это то, что Go, как и в случае с импортами, не позволяет иметь в программе неиспользуемые переменные. Например,</p>

    <pre><code class="language-go">func main() {
  name, power := "Goku", 1000
  fmt.Printf("default power is %d\n", power)
}
</code></pre>

    <p>не будет скомпилировано потому, что <code>name</code> была объявлена, но не используется. Как и неиспользуемые импорты это будет причинять одни расстройства, но в целом, я думаю, это улучшает чистоту кода и его читаемость.</p>

    <p>Еще многое предстоит узнать об объявлениях и присваиваниях. А пока запомните, что когда используется <code>var ИМЯ ТИП</code> переменная объявляется с нулевым значением, <code>ИМЯ := ЗНАЧЕНИЕ</code> значение присваивается одновременно с объявлением переменной, а <code>ИМЯ = ЗНАЧЕНИЕ</code> когда присваивается значение уже объявленной переменной.</p>

    <h2 id="">Объявление функций</h2>

    <p>Настало время рассказать о том, что функции могут возвращать несколько значений. Возьмем три функции: одна не возвращает значение, другая возвращает одно значение, и третья возвращает два значения.</p>

    <pre><code class="language-go">func log(message string) {
}

func add(a int, b int) int {
}

func power(name string) (int, bool) {
}
</code></pre>

    <p>Последнюю можно использовать так:</p>

    <pre><code class="language-go">value, exists := power("goku")
if exists == false {
  // handle this error case
}
</code></pre>

    <p>Иногда нужно только одно из возвращаемых значений. В этом случае другое значение присваивают переменной <code>_</code>:</p>

    <pre><code class="language-go">_, exists := power("goku")
if exists == false {
  // handle this error case
}
</code></pre>

    <p>Это больше, чем просто договорённость. <code>_</code> – пустой идентификатор, его особенность в том, что возвращаемое значение в действительности не присваивается. Это позволяет вам использовать <code>_</code> снова и снова не зависимо от возвращаемого типа переменной.</p>

    <p>И наконец еще кое-что, с чем вы наверняка столкнетесь при объявлении функций. Если параметры имеют одинаковый тип, можно использовать короткий синтаксис:</p>

    <pre><code class="language-go">func add(a, b int) int {

}
</code></pre>

    <p>Вы будете часто использовать возможность возвращения нескольких значений. И так же часто использовать идентификатор <code>_</code> для их игнорирования. Множественные возвращаемые значения и чуть более короткий способ указания параметров не являются обязательными правилами. Тем не менее, рано или поздно вы столкнетесь с ними, поэтому важно знать о них.</p>

    <h2 id="">Перед тем, как продолжить</h2>

    <p>Мы рассмотрели несколько небольших отдельных кусочков, кажущихся разрозненными на данном этапе. Мы будем постепенно создавать примеры побольше, в надежде, что куски сойдутся вместе.</p>

    <p>Если вы раньше работали с динамическим языком, сложности, связанные с типами и объявлениями, могут показаться шагом назад. Я соглашусь с вами. Для некоторых систем динамические языки являются более продуктивными.</p>

    <p>Если вы работали со статически типизированным языком, вы, вероятно, почувствуете себя комфортно с Go. Определяемые типы и множественные возвращаемые значения выглядят изящно (хотя, конечно, они есть не только в Go). Надеюсь, когда мы узнаем больше, вы оцените чистый и лаконичный синтаксис.</p>


</div>
</body>
</html>